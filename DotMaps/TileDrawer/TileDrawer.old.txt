using System;
using System.IO;
using System.Collections.Generic;
using System.Collections;
using DotMaps.Datastructures;
using DotMaps.Utils;
using System.Drawing;
using System.Drawing.Imaging;
using System.Xml;

namespace DotMaps
{
    class TileDrawerOLD
    {

        public TileDrawerOLD()
        {
            Console.WriteLine("Path to .osm file");
            //string path = Console.ReadLine();
            string path = @"C:\Users\Jann\Desktop\ersdorf.osm";
            Console.WriteLine("Path to save tiles:");
            //string newPath = Console.ReadLine();
            string newPath = @"C:\Users\Jann\Desktop\test";
            CreateTilesFromGraph(path, newPath, 1);
        }

        const int resolution = 1000;
        const int PenWidth = 5;

        public static void CreateTilesFromGraph(string path, string newPath, float lengthCellLateralEdgeClosestToEquator)
        {
            Hashtable visible = new Hashtable();
            foreach (string type in File.ReadAllLines("visible.txt"))
                visible.Add(type.Split(',')[0], Convert.ToByte(type.Split(',')[1]));
            Hashtable colors = new Hashtable();
            foreach (string type in File.ReadAllLines("visible.txt"))
            {
                if (!colors.ContainsKey(type.Split(',')[0]))
                {
                    switch ((string)type.Split(',')[2])
                    {
                        case "Red":
                            colors.Add(type.Split(',')[0], Color.Red);
                            break;
                        case "Orange":
                            colors.Add(type.Split(',')[0], Color.Orange);
                            break;
                        case "White":
                            colors.Add(type.Split(',')[0], Color.White);
                            break;
                        case "Gray":
                            colors.Add(type.Split(',')[0], Color.Gray);
                            break;
                        case "Yellow":
                            colors.Add(type.Split(',')[0], Color.Yellow);
                            break;
                        case "Green":
                            colors.Add(type.Split(',')[0], Color.Green);
                            break;
                        case "Blue":
                            colors.Add(type.Split(',')[0], Color.Blue);
                            break;
                        case "LightBlue":
                            colors.Add(type.Split(',')[0], Color.LightBlue);
                            break;
                        default:
                            colors.Add(type.Split(',')[0], Color.Black);
                            break;
                    }
                }
            }
            float minLat = float.MaxValue, maxLat = float.MinValue, minLon = float.MaxValue, maxLon = float.MinValue;

            Hashtable nodes = new Hashtable();

            XmlReaderSettings settings = new XmlReaderSettings();
            settings.IgnoreWhitespace = true;
            using (XmlReader reader = XmlReader.Create(path, settings))
            {
                while (reader.Read())
                {
                    if (reader.NodeType != XmlNodeType.EndElement && reader.Depth == 1 && reader.Name == "node")
                    {
                        UInt64 id = Convert.ToUInt64(reader.GetAttribute("id"));
                        float lat = Convert.ToSingle(reader.GetAttribute("lat").Replace('.', ','));
                        float lon = Convert.ToSingle(reader.GetAttribute("lon").Replace('.', ','));
                        nodes.Add(id, new Node(id, lat, lon));
                        minLat = lat < minLat ? lat : minLat;
                        minLon = lon < minLon ? lon : minLon;
                        maxLat = lat > maxLat ? lat : maxLat;
                        maxLon = lon > maxLon ? lon : maxLon;
                    }
                }
                reader.Close();
            }

            for (int level = 7; level > 0; level--)
            {
                float CellSize = lengthCellLateralEdgeClosestToEquator * (float)Math.Pow(level, 2);

                List<Line>[,] drawGrid = Functions.EmptyGridFromBounds(CellSize, minLat, maxLat, minLon, maxLon);
                Console.WriteLine("{0}x{1}\t\t-->{2}km", maxLat, minLon, (int)Functions.DistanceBetweenCoordinates(minLat, minLon, minLat, maxLon) + 1);
                Console.WriteLine("\\|/\t\tGrid");
                Console.WriteLine(" {2}km\t\t\t{0}x{1}", minLat, maxLon, (int)Functions.DistanceBetweenCoordinates(minLat, minLon, maxLat, minLon) + 1);
                Console.WriteLine("{0}x{1} Cells", drawGrid.GetLength(0), drawGrid.GetLength(1));

                double width = Functions.DistanceBetweenCoordinates(minLat, minLon, minLat, maxLon);
                double height = Functions.DistanceBetweenCoordinates(minLat, minLon, maxLat, minLon);


                using (XmlReader reader = XmlReader.Create(path))
                {
                    const byte UNKNOWN = 0, NODE = 1, WAY = 2, READING = 1, DONE = 0;
                    byte nodeType = UNKNOWN, state = DONE;
                    Way currentWay = new Way(0);
                    while (reader.Read())
                    {
                        if (reader.NodeType != XmlNodeType.EndElement)
                        {
                            if (reader.Depth == 1)
                            {
                                if (state == READING && nodeType == WAY)
                                {
                                    state = DONE;
                                    if (currentWay.tags.ContainsKey("highway"))
                                    {
                                        Node[] waynodes = currentWay.nodes.ToArray();
                                        for (int i = 1; i < waynodes.Length; i++)
                                        {
                                            int[] lineStart = Functions.GridFromCoordinates(CellSize, maxLat, minLon, waynodes[i - 1].lat, waynodes[i - 1].lon);
                                            int[] lineFinish = Functions.GridFromCoordinates(CellSize, maxLat, minLon, waynodes[i].lat, waynodes[i].lon);
                                            int gridMinX = lineStart[0] < lineFinish[0] ? lineStart[0] : lineFinish[0];
                                            int gridMaxX = lineStart[0] > lineFinish[0] ? lineStart[0] : lineFinish[0];
                                            int gridMinY = lineStart[1] < lineFinish[1] ? lineStart[1] : lineFinish[1];
                                            int gridMaxY = lineStart[1] > lineFinish[1] ? lineStart[1] : lineFinish[1];
                                            for (int x = gridMinX; x <= gridMaxX; x++)
                                            {
                                                for (int y = gridMinY; y <= gridMaxY; y++)
                                                {
                                                    Color c = Color.Green;
                                                    if (colors.ContainsKey((string)currentWay.tags["highway"]))
                                                        c = (Color)colors[(string)currentWay.tags["highway"]];
                                                    drawGrid[x, y].Add(new Line(waynodes[i - 1].lat, waynodes[i - 1].lon, waynodes[i].lat, waynodes[i].lon, c, PenWidth));
                                                }
                                            }
                                        }
                                    }
                                }
                                switch (reader.Name)
                                {
                                    case "node":
                                        nodeType = NODE;
                                        break;
                                    case "way":
                                        currentWay = new Way(Convert.ToUInt64(reader.GetAttribute("id")));
                                        nodeType = WAY;
                                        break;
                                    default:
                                        nodeType = UNKNOWN;
                                        break;
                                }
                            }
                            else if (reader.Depth == 2 && nodeType == WAY)
                            {
                                state = READING;
                                switch (reader.Name)
                                {
                                    case "nd":
                                        UInt64 id = Convert.ToUInt64(reader.GetAttribute("ref"));
                                        currentWay.nodes.Add((Node)nodes[id]);
                                        break;
                                    case "tag":
                                        string key = reader.GetAttribute("k");
                                        if (key.StartsWith("addr:") || key == "building" || key == "ref" || key == "highway" || key == "name" || key == "maxspeed" || key == "oneway")
                                            currentWay.tags.Add(key, reader.GetAttribute("v"));
                                        break;
                                }
                            }
                        }
                    }
                    reader.Close();
                }

                for (int gridX = 0; gridX < drawGrid.GetLength(0); gridX++)
                {

                    for (int gridY = 0; gridY < drawGrid.GetLength(1); gridY++)
                    {
                        Directory.CreateDirectory(@newPath + "\\" + level + "\\" + gridX );
                        float[] gridMaxLatMinLon = Functions.GridCellMaxLatMinLon(CellSize * (float)Math.Pow(level, 2), minLat, maxLat, minLon, gridX, gridY);
                        using (Bitmap bmp = new Bitmap(resolution, resolution))
                        {
                            using (Graphics graphics = Graphics.FromImage(bmp))
                            {
                                foreach (Line line in drawGrid[gridX, gridY])
                                {
                                    float[] pixelCoordinatesStart = Functions.PixelsFromCoordinates(resolution, gridMaxLatMinLon[0], gridMaxLatMinLon[1], line.startLat, line.startLon);
                                    float[] pixelCoordinatesFinish = Functions.PixelsFromCoordinates(resolution, gridMaxLatMinLon[0], gridMaxLatMinLon[1], line.finishLat, line.finishLon);
                                    Pen pen = new Pen(line.color, line.width);
                                    graphics.DrawLine(pen, pixelCoordinatesStart[0], pixelCoordinatesStart[1], pixelCoordinatesFinish[0], pixelCoordinatesFinish[1]);
                                }
                            }
                            bmp.Save(@newPath + "\\" + level + "\\" + gridX + "\\" + gridY + ".png", ImageFormat.Png);
                        }
                        
                    }
                }
            }
        }

    }
}
